import java.util.Hashtable;

public class Generic {
	public static void main(String[] args) {
		Testfx<String, String> t = new Testfx<String, String>();
		t.put("key", "value");
		String s = t.get("key");
		System.out.println(s);
	}

}

class Testfx<C, Q> {// 类的参数时C和Q,传入分值时String类型,这个类没有特定的待处理型别,更像是一个模板
	public Hashtable<C, Q> h = new Hashtable<C, Q>();

	public void put(C c, Q q) {
		h.put(c, q);
	}

	public Q get(C c) {
		return h.get(c);
	}
}
// 泛型是Java SE 1.5的新特性,泛型的本质是参数化类型
// 也就是说操作的数据类型被指定为一个参数,这种参数类型可以用在类、接口和方法的创建中
// 分别称为泛型类/泛型接口/泛型方法
// 在Java SE 1.5之前，没有泛型的情况下,通过对类型Object的引用来实现参数的“任意化”
// 参数的任意化所带来的缺点是要做显式的强制类型转换,而这种转换是要求开发者对实际参数类型可以预知的情况下进行的
// 对于强制类型转换错误的情况,编译器可能不提示错误,在运行的时候才出现异常,这是一个安全隐患
// 泛型的好处是在编译的时候检查类型安全,并且所有的强制转换都是自动和隐式的,可提高代码的重用率
// 表面上看起来,无论语法还是应用的环境(例如容器类),泛型类型(或者泛型)都类似于C++中的模板,但是这种相似性仅限于表面
// Java语言中的泛型基本上完全在编译器中实现,由编译器执行类型检查和类型推断,然后生成普通的非泛型的字节码,泛型是Java类走向类型安全的重要一步
// 如果一个类的后面跟上一个尖括号,则表示这个类是泛型类,可以这样声明:
// class A<E>
// A是泛型类的名称,E是泛型
// 泛型在使用中还有如下一些规则和限制:
// 泛型的类型参数只能是类类型(包括自定义类),不能是简单类型
// 同一种泛型可以对应多个版本(因为参数类型是不确定的),不同版本的泛型类实例是不兼容的
// 泛型的类型参数可以有多个
// 实际上Java的泛型就是创建一个用类型作为参数的类,就像写带参数的方法一样